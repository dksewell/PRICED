% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PRICED.R
\name{PRICED}
\alias{PRICED}
\title{Perform inference for the PRICED model}
\usage{
PRICED(
  formula_prevalence,
  formula_incidence,
  formula_clearance,
  data,
  prior_prevalence = list(location = 0, scale = 2.5, autoscale = TRUE),
  prior_incidence = list(location = 0, scale = 2.5, autoscale = TRUE),
  prior_clearance = list(location = 0, scale = 2.5, autoscale = TRUE),
  sensitivity = 0.75,
  specificity = 0.98,
  method = c("normal", "adaptMCMC")[1],
  n_draws = 5000,
  seed = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{formula_prevalence}{Right handed formula of the form  ~ x_1 + x_2 + ...}

\item{formula_incidence}{Right handed formula of the form  ~ x_1 + x_2 + ...}

\item{formula_clearance}{Formula of the form y ~ x_1 + x_2 + ... + (time_variable | subject_ID)}

\item{data}{Data frame or tibble}

\item{prior_clearance, prior_incidence, prior_beta_pr}{a list giving the normal hyperparameters location and scale (i.e., sd).
Additionally, autoscale can be set to TRUE, in which case the scale will be
divided by the standard deviation of the covariates for each regression coefficient.}

\item{sensitivity}{Diagnostic test sensitivity}

\item{specificity}{Diagnostic test specificity}

\item{method}{character, either "normal" for asymptotic normal approximation of the posterior (default), or
"adaptMCMC" to use adaptive MCMC sampling using the adaptMCMC package.}

\item{n_draws}{integer, number of posterior draws to obtain (not used if method = "normal")}

\item{seed}{a single value, interpreted as an integer.  Used for replication purposes.}

\item{verbose}{logical.  Whether to print messages as to where the model fitting algorithm is.}

\item{...}{Further arguments passed to adaptMCMC::MCMC() (if method = "adaptMCMC", otherwise ignored)
For example, you'll probably want to pass in acc.rate = 0.234.}
}
\value{
Object of class 'PRICED' which has the following elements:
\itemize{
\item coefficients  posterior mean of the regression coefficients
\item covariance posterior covariance matrix (rows/columns in same order as coefficients)
\item samples  if method = "adaptMCMC", the posterior samples, minus 10\% for burnin
\item acceptance rate  if method = "adaptMCMC", the acceptance rate
\item formula_prevalence, formula_incidence, formula_clearance
\item priors  list of prior hyperparameters
}
}
\description{
Obtain posterior samples based on data fit to
the PRICED model, a set of regression models for
CLearance, Incidence, and Prevalence, accounting for
diagnostic errors.
}
\examples{
PRICED_data =
  simulate_PRICED(seed = 2023,N_subj = 500, N_time = 10)

formula_clearance =  p_observed ~ x1 + x2 + (time | subject)
formula_clearance_oracle =  p ~ x1 + x2 + (time | subject)
formula_incidence =  ~ x1 + x3
formula_prevalence =  ~ x1

# Fit the oracle model (no diagnostic error introduced)
PRICED_fit0 =
  PRICED(formula_prevalence,
         formula_incidence,
         formula_clearance_oracle,
         PRICED_data$data[[1]],
         prior_prevalence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_incidence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_clearance = list(location = 0, scale = 2.5, autoscale = TRUE),
         method = "normal",
         seed = 1,
         sensitivity = 1,
         specificity = 1,
         verbose = TRUE)

# Fit the PRICED model, accounting for diagnostic error
PRICED_fit1 =
  PRICED(formula_prevalence,
         formula_incidence,
         formula_clearance,
         PRICED_data$data[[1]],
         prior_prevalence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_incidence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_clearance = list(location = 0, scale = 2.5, autoscale = TRUE),
         method = "normal",
         seed = 1,
         sensitivity = 0.75,
         specificity = 0.98,
         verbose = TRUE)

# Fit the model, ignoring diagnostic error
PRICED_fit2 =
  PRICED(formula_prevalence,
         formula_incidence,
         formula_clearance,
         PRICED_data$data[[1]],
         prior_prevalence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_incidence = list(location = 0, scale = 2.5, autoscale = TRUE),
         prior_clearance = list(location = 0, scale = 2.5, autoscale = TRUE),
         method = "normal",
         seed = 1,
         sensitivity = 1,
         specificity = 1,
         verbose = TRUE)

# Collate the results
library(tibble)
collated_results =
  tibble(parameter = names(unlist(PRICED_data$parameters[[1]][c(3:1)])),
         truth = unlist(PRICED_data$parameters[[1]][3:1]),
         `oracle estimate` = coef(PRICED_fit0),
         `PRICED estimate` = coef(PRICED_fit1),
         `naive estimate` = coef(PRICED_fit2))
print(collated_results)

#Compute MSE:
mean((collated_results$`oracle estimate` - collated_results$truth)^2)
mean((collated_results$`PRICED estimate` - collated_results$truth)^2)
mean((collated_results$`naive estimate` - collated_results$truth)^2)


}
